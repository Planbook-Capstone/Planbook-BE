name: Deploy Spring Boot Backend with Docker Compose (Local Build)

on:
  push:
    branches:
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      # Bước này cần thiết để tạo ra file JAR
      - name: Maven Clean and Package
        run: mvn clean package -DskipTests

      # Bước này tạo file docker-compose.yml động trên runner
      - name: Create docker-compose.yml on runner
        run: |
          cat <<EOF > docker-compose.yml
          version: '3.8'

          services:
            zookeeper:
              image: zookeeper:latest
              container_name: zookeeper
              restart: always
              ports:
                - "2181:2181"
              environment:
                ZOO_CLIENT_PORT: 2181 

            kafka:
              image: confluentinc/cp-kafka:7.5.0
              container_name: kafka
              restart: always
              ports:
                - "9092:9092"
              environment:
                KAFKA_BROKER_ID: 1
                KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
                KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
                KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
                KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
                KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
              depends_on:
                - zookeeper

            kafdrop:
              image: obsidiandynamics/kafdrop:latest
              container_name: kafdrop
              restart: always
              ports:
                - "9000:9000"
              environment:
                KAFKA_BROKERCONNECT: kafka:29092
                JVM_OPTS: "-Xms16M -Xmx48M"
              depends_on:
                - kafka

            redis:
              image: redis:latest
              container_name: redis
              restart: always
              ports:
                - "6379:6379"

            backend:
              build:
                context: .
                dockerfile: Dockerfile
              image: planbook-be:latest
              # ĐÃ XÓA: container_name: planbook-be
              # Docker Swarm sẽ tự quản lý tên container khi bạn dùng `docker stack deploy`.
              # Giữ dòng này sẽ bị bỏ qua và có thể gây nhầm lẫn nếu bạn vẫn chạy `docker compose` thủ công.
              restart: always
              ports:
                - "8080:8080"
              environment:
                SPRING_DATASOURCE_URL: "${{ secrets.DB_URL }}"
                SPRING_DATASOURCE_USERNAME: "${{ secrets.DB_USERNAME }}"
                SPRING_DATASOURCE_PASSWORD: "${{ secrets.DB_PASSWORD }}"
                SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT: "org.hibernate.dialect.MySQL8Dialect"
                SPRING_JPA_HIBERNATE_DDL_AUTO: "update"
                SPRING_MAIN_ALLOW_CIRCULAR_REFERENCES: "true"
                SPRING_MVC_PATHMATCH_MATCHING_STRATEGY: "ANT_PATH_MATCHER"
                SUPABASE_JWT_SECRET: "${{ secrets.SUPABASE_JWT_SECRET_KEY }}"
                SPRING_SECRETKEY: "${{ secrets.SPRING_APP_SECRET_KEY }}"
                SPRING_KAFKA_BOOTSTRAP_SERVERS: "kafka:29092"
                KAFKA_TOPIC_NAME: "${{ secrets.KAFKA_TOPIC }}"
                SPRING_MAIL_HOST: "${{ secrets.MAIL_HOST }}"
                SPRING_MAIL_PORT: "${{ secrets.MAIL_PORT }}"
                SPRING_MAIL_USERNAME: "${{ secrets.MAIL_USERNAME }}"
                SPRING_MAIL_PASSWORD: "${{ secrets.MAIL_PASSWORD }}"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH: "true"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE: "true"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_REQUIRED: "true"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_CONNECTIONTIMEOUT: "5000"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_TIMEOUT: "5000"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_WRITETIMEOUT: "5000"
                SPRING_MAIL_DEFAULT_ENCODING: "UTF-8"
                SPRING_DATA_REDIS_HOST: "redis"
                SPRING_DATA_REDIS_PORT: "6379"
                SPRING_CACHE_TYPE: "redis"
                SPRING_DURATION: "${{ secrets.APP_DURATION }}"
                SPRING_PROFILES_ACTIVE: "prod"
              depends_on:
                - zookeeper
                - kafka
                - redis
              # =========================================================
              # THÊM PHẦN DEPLOY NÀY CHO DOCKER SWARM
              deploy:
                replicas: 1 # Chỉ chạy 1 instance của backend
                update_config:
                  parallelism: 1 # Cập nhật từng container một
                  delay: 10s     # Chờ 10 giây giữa các bước cập nhật
                  order: start-first # Khởi động container mới trước khi dừng container cũ
                                     # -> Đảm bảo không có downtime trong quá trình cập nhật
                rollback_config:
                  parallelism: 1
                  delay: 10s
                  order: stop-first # Dừng container lỗi trước khi quay lại cái cũ
                restart_policy:
                  condition: on-failure # Khởi động lại nếu container thất bại
                healthcheck: # Định nghĩa healthcheck cho Docker Swarm
                  test: ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
                  interval: 30s # Kiểm tra mỗi 30 giây
                  timeout: 10s  # Timeout nếu không phản hồi trong 10 giây
                  retries: 3    # Thử lại 3 lần trước khi đánh dấu là thất bại
                  start_period: 60s # Thời gian chờ cho ứng dụng khởi động lần đầu (ví dụ 60s)
                                    # Trong thời gian này, health check không tính vào retries
              # =========================================================
          EOF
        shell: bash

      # Bước này copy tất cả file cần thiết lên VPS
      - name: Copy Project Files to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "."
          target: /var/www/be/

      # BƯỚC MỚI: TRIỂN KHAI VỚI DOCKER STACK (THAY THẾ 2 BƯỚC CŨ Stop/Start)
      - name: Deploy Application with Docker Stack on VPS (Swarm Mode)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e # Exit immediately if a command exits with a non-zero status.

            cd /var/www/be || { echo "Error: /var/www/be directory not found on VPS."; exit 1; }
            echo "Deploying application using Docker Stack (Swarm Mode)..."

            # 1. Dọn dẹp ban đầu các container Docker Compose cũ (không phải Swarm-managed)
            # Điều này quan trọng cho lần chuyển đổi đầu tiên từ docker-compose up sang docker stack deploy.
            echo "Attempting to clean up old standalone Docker Compose containers (if any)..."
            docker compose -f docker-compose.yml down -v --remove-orphans --timeout 0 2>/dev/null || true
            docker stop planbook-be zookeeper kafka kafdrop redis 2>/dev/null || true
            docker rm -f planbook-be zookeeper kafka kafdrop redis 2>/dev/null || true
            docker rmi planbook-be:latest 2>/dev/null || true # Xóa image `latest` cũ để đảm bảo build lại
            echo "Old containers and images cleaned up (if any)."

            # 2. Export environment variables cho docker stack deploy
            # Docker Swarm có cơ chế secrets và configs riêng, nhưng giữ cách này để tương thích.
            export SPRING_DATASOURCE_URL="${{ secrets.DB_URL }}"
            export SPRING_DATASOURCE_USERNAME="${{ secrets.DB_USERNAME }}"
            export SPRING_DATASOURCE_PASSWORD="${{ secrets.DB_PASSWORD }}"
            export SUPABASE_JWT_SECRET="${{ secrets.SUPABASE_JWT_SECRET_KEY }}"
            export SPRING_SECRETKEY="${{ secrets.SPRING_APP_SECRET_KEY }}"
            export KAFKA_TOPIC_NAME="${{ secrets.KAFKA_TOPIC }}"
            export SPRING_MAIL_HOST="${{ secrets.MAIL_HOST }}"
            export SPRING_MAIL_PORT="${{ secrets.MAIL_PORT }}"
            export SPRING_MAIL_USERNAME="${{ secrets.MAIL_USERNAME }}"
            export SPRING_MAIL_PASSWORD="${{ secrets.MAIL_PASSWORD }}"
            export SPRING_DATA_REDIS_HOST="redis" # Giữ nguyên tên dịch vụ trong compose
            export SPRING_DATA_REDIS_PORT="6379"
            export SPRING_DURATION="${{ secrets.APP_DURATION }}"
            
            # 3. Triển khai hoặc cập nhật stack
            # Docker stack deploy sẽ tự động build image nếu cần (do có 'build' trong compose file)
            # và sau đó triển khai/cập nhật các dịch vụ theo cấu hình 'deploy'.
            echo "Running docker stack deploy..."
            docker stack deploy -c docker-compose.yml planbook-stack # 'planbook-stack' là tên stack của bạn

            echo "Deployment initiated. Check service status with 'docker service ls' and logs with 'docker service logs planbook-stack_backend'"
            echo "Waiting for 'planbook-stack_backend' service to be stable..."

            # 4. Kiểm tra trạng thái của dịch vụ sau khi deploy
            # Điều này giúp workflow chờ đợi deploy hoàn tất và healthcheck thành công.
            ATTEMPTS=0
            MAX_ATTEMPTS=60 # Tối đa 60*5 = 300 giây (5 phút) để chờ
            SERVICE_NAME="planbook-stack_backend" # Tên dịch vụ backend trong Swarm

            while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
              # Lấy số lượng replica đang chạy
              RUNNING_REPLICAS=$(docker service ps "$SERVICE_NAME" --filter "desired-state=running" --format "{{.CurrentState}}" | grep -i "Running" | wc -l)
              # Lấy số lượng replica mong muốn
              REPLICAS_EXPECTED=$(docker service inspect --format '{{.Spec.Replicas}}' "$SERVICE_NAME")
              
              # Lấy trạng thái health của service (từ một replica bất kỳ, nếu có nhiều)
              # Dùng `docker inspect` để có thông tin health đầy đủ hơn
              HEALTH_STATUS_OUTPUT=$(docker service ps "$SERVICE_NAME" --format "{{.ID}}\t{{.Name}}\t{{.CurrentState}}\t{{.Health}}" | grep "$SERVICE_NAME" | head -n 1)
              HEALTH_STATUS="unknown"
              if echo "$HEALTH_STATUS_OUTPUT" | grep -q "healthy"; then
                  HEALTH_STATUS="healthy"
              elif echo "$HEALTH_STATUS_OUTPUT" | grep -q "unhealthy"; then
                  HEALTH_STATUS="unhealthy"
              fi

              echo "  Attempt $((ATTEMPTS+1))/$MAX_ATTEMPTS: Service '$SERVICE_NAME' - Running: $RUNNING_REPLICAS/$REPLICAS_EXPECTED. Health: $HEALTH_STATUS."

              if [ "$RUNNING_REPLICAS" -ge "$REPLICAS_EXPECTED" ] && [ "$HEALTH_STATUS" == "healthy" ]; then
                echo "Service '$SERVICE_NAME' is running and healthy. Deployment successful!"
                break
              fi
              
              sleep 5
              ATTEMPTS=$((ATTEMPTS+1))
            done

            if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
              echo "Error: Service '$SERVICE_NAME' did not become stable (healthy and running) after $MAX_ATTEMPTS attempts. Deployment failed."
              # Khi triển khai bằng stack deploy, nếu deploy thất bại, Swarm sẽ tự động rollback
              # hoặc giữ phiên bản cũ nếu `order: start-first` được tuân thủ.
              # Tuy nhiên, chúng ta vẫn báo lỗi cho CI/CD để biết.
              exit 1
            fi
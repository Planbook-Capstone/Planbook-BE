name: Deploy Spring Boot Backend with Docker Compose (Local Build)

on:
  push:
    branches:
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Maven Clean and Package
        run: mvn clean package -DskipTests

      - name: Create docker-compose.yml on runner
        run: |
          cat <<EOF > docker-compose.yml
          version: '3.8'

          services:
            zookeeper:
              image: zookeeper:latest
              container_name: zookeeper
              restart: always
              ports:
                - "2181:2181"
              environment:
                ZOO_CLIENT_PORT: 2181
              volumes:
                - zookeeper_data:/data
                - zookeeper_datalog:/datalog

            kafka:
              image: confluentinc/cp-kafka:7.5.0
              container_name: kafka
              restart: always
              ports:
                - "9092:9092"
              environment:
                KAFKA_BROKER_ID: 1
                KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
                KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
                KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
                KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
                KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
              volumes:
                - kafka_data:/var/lib/kafka/data
              depends_on:
                - zookeeper

            kafdrop:
              image: obsidiandynamics/kafdrop:latest
              container_name: kafdrop
              restart: always
              ports:
                - "9000:9000"
              environment:
                KAFKA_BROKERCONNECT: kafka:29092
                JVM_OPTS: "-Xms16M -Xmx48M"
              depends_on:
                - kafka

            redis:
              image: redis:latest
              container_name: redis
              restart: always
              ports:
                - "6379:6379"
              volumes:
                - redis_data:/data

            backend:
              build:
                context: .
                dockerfile: Dockerfile
              image: planbook-be:latest
              container_name: planbook-be
              restart: always
              ports:
                - "8080:8080"
              environment:
                SPRING_DATASOURCE_URL: "${{ secrets.DB_URL }}"
                SPRING_DATASOURCE_USERNAME: "${{ secrets.DB_USERNAME }}"
                SPRING_DATASOURCE_PASSWORD: "${{ secrets.DB_PASSWORD }}"
                SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT: "org.hibernate.dialect.MySQL8Dialect"
                SPRING_JPA_HIBERNATE_DDL_AUTO: "update"
                SPRING_MAIN_ALLOW_CIRCULAR_REFERENCES: "true"
                SPRING_MVC_PATHMATCH_MATCHING_STRATEGY: "ANT_PATH_MATCHER"
                SUPABASE_JWT_SECRET: "${{ secrets.SUPABASE_JWT_SECRET_KEY }}"
                SPRING_SECRETKEY: "${{ secrets.SPRING_APP_SECRET_KEY }}"
                SPRING_KAFKA_BOOTSTRAP_SERVERS: "kafka:29092"
                KAFKA_TOPIC_NAME: "${{ secrets.KAFKA_TOPIC }}"
                SPRING_MAIL_HOST: "${{ secrets.MAIL_HOST }}"
                SPRING_MAIL_PORT: "${{ secrets.MAIL_PORT }}"
                SPRING_MAIL_USERNAME: "${{ secrets.MAIL_USERNAME }}"
                SPRING_MAIL_PASSWORD: "${{ secrets.MAIL_PASSWORD }}"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH: "true"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE: "true"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_REQUIRED: "true"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_CONNECTIONTIMEOUT: "5000"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_TIMEOUT: "5000"
                SPRING_MAIL_PROPERTIES_MAIL_SMTP_WRITETIMEOUT: "5000"
                SPRING_MAIL_DEFAULT_ENCODING: "UTF-8"
                SPRING_DATA_REDIS_HOST: "redis"
                SPRING_DATA_REDIS_PORT: "6379"
                SPRING_CACHE_TYPE: "redis"
                SPRING_DURATION: "${{ secrets.APP_DURATION }}"
                SPRING_PROFILES_ACTIVE: "prod"
              depends_on:
                - zookeeper
                - kafka
                - redis
          volumes:
            zookeeper_data:
            zookeeper_datalog:
            kafka_data:
            redis_data:
          EOF
        shell: bash

      - name: Backup current docker-compose.yml and images on VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /var/www/be || exit 1
            # Backup docker-compose.yml
            if [ -f docker-compose.yml ]; then
              cp docker-compose.yml docker-compose.yml.bak
              echo "Backed up docker-compose.yml to docker-compose.yml.bak"
            fi
            # Tag current backend image as old-version for rollback
            # Check if planbook-be:latest exists before tagging
            if docker images -q planbook-be:latest > /dev/null; then
              docker tag planbook-be:latest planbook-be:old-version
              echo "Tagged planbook-be:latest as planbook-be:old-version"
            else
              echo "No planbook-be:latest image found to backup. This might be the first deployment or a cleanup issue."
            fi
            echo "Old docker-compose.yml and image backup attempt completed."

      - name: Copy Project Files to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "."
          target: /var/www/be/

      - name: Stop and Remove Old Backend Container on VPS (Prepare for new deployment)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /var/www/be || exit 1
            echo "Stopping and removing old planbook-be container if it exists..."
            docker stop planbook-be 2>/dev/null || true
            docker rm -f planbook-be 2>/dev/null || true
            # Remove the 'latest' tag to ensure the new build gets this tag cleanly
            docker rmi planbook-be:latest 2>/dev/null || true
            echo "Old backend container and image cleaned up (if existed). Dependent services will be managed by 'docker compose up'."
            
            # Additional check for port 8080 (optional but good practice)
            echo "Checking and freeing up port 8080 (if still in use by other processes)..."
            PORT_TO_FREE=8080
            PID_ON_PORT=$(sudo lsof -t -i :$PORT_TO_FREE)
            if [ -n "$PID_ON_PORT" ]; then
              echo "Found process on port $PORT_TO_FREE with PID: $PID_ON_PORT. Attempting to kill it..."
              sudo kill -9 $PID_ON_PORT 2>/dev/null || true
              sleep 1
              if sudo lsof -i :$PORT_TO_FREE > /dev/null; then
                echo "Warning: Port $PORT_TO_FREE is still in use after killing process $PID_ON_PORT. Manual intervention may be needed."
              else
                echo "Port $PORT_TO_FREE is now free."
              fi
            else
              echo "Port $PORT_TO_FREE is already free."
            fi


      - name: Deploy new version and perform health check
        id: deploy_check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /var/www/be || exit 1
            echo "Building and starting Docker Compose services with new version..."
            # --force-recreate to ensure new containers are created from potentially new images
            # --build to rebuild the 'backend' image with the latest source
            docker compose -f docker-compose.yml up --build -d --remove-orphans

            echo "Waiting for backend service to become healthy (max 120 seconds)..."
            # Health check loop for backend service (requires HEALTHCHECK in Dockerfile)
            MAX_RETRIES=20
            RETRY_INTERVAL=6 # 6 seconds per retry, total 120 seconds
            
            # Give Docker Compose a moment to actually start the containers
            sleep 10 

            for i in $(seq 1 $MAX_RETRIES); do
              CONTAINER_ID=$(docker ps -aqf "name=planbook-be")
              if [ -z "$CONTAINER_ID" ]; then
                echo "Backend container not found, likely failed to start. Aborting deployment."
                exit 1 # Indicate failure
              fi
            
              HEALTH_STATUS=$(docker inspect --format='{{json .State.Health.Status}}' $CONTAINER_ID 2>/dev/null || echo "\"unknown\"")
              echo "Attempt $i: Backend health status: $HEALTH_STATUS"

              if [ "$HEALTH_STATUS" == "\"healthy\"" ]; then
                echo "Backend service is healthy."
                exit 0 # Success
              elif [ "$HEALTH_STATUS" == "\"unhealthy\"" ]; then
                echo "Backend service is unhealthy. Aborting deployment."
                exit 1 # Failure
              fi
              sleep $RETRY_INTERVAL
            done
            echo "Backend service did not become healthy within the timeout ($((MAX_RETRIES * RETRY_INTERVAL))s)."
            exit 1 # Failure after timeout
        timeout-minutes: 5 # Total timeout for this step
        continue-on-error: true # Allow subsequent steps (rollback) to run even if this fails

      - name: Rollback if deployment failed
        if: steps.deploy_check.outcome != 'success'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /var/www/be || exit 1
            echo "Deployment failed! Initiating rollback to previous version..."
            
            # 1. Stop and remove newly deployed (failed) containers
            docker compose down 2>/dev/null || true
            echo "Stopped all current Docker Compose services."
            
            # 2. Restore old docker-compose.yml
            if [ -f docker-compose.yml.bak ]; then
              mv docker-compose.yml.bak docker-compose.yml
              echo "Restored docker-compose.yml from backup."
            else
              echo "Warning: No docker-compose.yml.bak found for rollback. Cannot restore old compose file."
              # Continue anyway, might just be the image causing issues
            fi

            # 3. Revert backend image to old-version tag
            # First, ensure the 'latest' tag points to the old version
            if docker images -q planbook-be:old-version > /dev/null; then
              docker rmi -f planbook-be:latest 2>/dev/null || true # Remove the failed 'latest' image
              docker tag planbook-be:old-version planbook-be:latest
              echo "Restored planbook-be:old-version to planbook-be:latest."
            else
              echo "Warning: No 'planbook-be:old-version' image found for rollback. Cannot revert backend image."
              # Continue anyway, rely on restored compose file
            fi
            
            echo "Starting services with previous configuration..."
            docker compose -f docker-compose.yml up -d --remove-orphans
            
            echo "Rollback sequence completed. Please manually verify the application on VPS."
            exit 1 # Mark the GitHub Action as failed to clearly indicate a rollback occurred